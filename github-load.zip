# Creating the proprietary ZIP package for Gabriel and Noah with IP files and C++ code.
# This will produce /mnt/data/prime-spectrum-ip.zip with the requested structure.
import os
import textwrap
import zipfile

base = "/mnt/data/prime-spectrum-ip"
os.makedirs(base, exist_ok=True)

def write(path, content):
    full = os.path.join(base, path)
    d = os.path.dirname(full)
    if d and not os.path.exists(d):
        os.makedirs(d, exist_ok=True)
    with open(full, "w", encoding="utf-8") as f:
        f.write(content)

# LICENSE (proprietary)
write("LICENSE", textwrap.dedent("""\
Copyright © 2025 Gabriel Neal Christensen and Noah Christensen
All rights reserved.

Permission is NOT granted to copy, modify, merge, publish, distribute,
sublicense, or sell copies of this software or associated materials,
in whole or in part, without express written permission from the authors.

The authors reserve all intellectual property rights to the concepts,
mathematical proofs, and code contained in this repository.
"""))

# COPYRIGHT
write("COPYRIGHT", textwrap.dedent("""\
This repository and its contents are the original intellectual property of:

- Gabriel Neal Christensen
- Noah Christensen

All code, algorithms, and mathematical proofs herein were created solely
by the above authors. Any reproduction or distribution without written
permission is prohibited.
"""))

# README.md
write("README.md", textwrap.dedent("""\
# Prime Spectrum–Riemann Correspondence
By Gabriel Neal Christensen & Noah Christensen

This repository contains:
- The original mathematical proof connecting prime distribution to zeta zeros.
- A C++ implementation of the Prime Spectrum algorithm (prime indicator sequence utilities).
- Supporting materials for experiments and reproduction.

Status: Proprietary — All Rights Reserved.

Authorship:
Copyright © 2025 Gabriel Neal Christensen and Noah Christensen

License: Proprietary — do not copy or distribute without written permission.
"""))

# src/prime_spectrum.cpp (from earlier C++ code, slightly polished)
write("src/prime_spectrum.cpp", textwrap.dedent("""\
// prime_spectrum.cpp
// C++17 implementation of T[n] utilities for odd primes o_n = 2n+1
// Authors: Gabriel Neal Christensen & Noah Christensen
// Copyright © 2025 Gabriel Neal Christensen and Noah Christensen
#include <bits/stdc++.h>
using namespace std;

vector<int> primes_upto(int limit) {
    if (limit < 2) return {};
    vector<char> is_prime(limit+1, 1);
    is_prime[0]=is_prime[1]=0;
    int r = (int)floor(sqrt((double)limit));
    for (int p=2;p<=r;++p) if (is_prime[p]) {
        for (long long q=1LL*p*p;q<=limit;q+=p) is_prime[(size_t)q]=0;
    }
    vector<int> primes;
    for (int i=2;i<=limit;++i) if (is_prime[i]) primes.push_back(i);
    return primes;
}

int T_from_formula(long long n, const vector<int>* primes_opt=nullptr) {
    if (n < 1) return 0;
    long long o = 2*n + 1;
    if (o == 3) return 1;
    vector<int> local_primes;
    const vector<int>* primes = primes_opt;
    if (!primes) {
        int lim = (int)floor(sqrt((long double)o)) + 1;
        local_primes = primes_upto(max(lim, 3));
        primes = &local_primes;
    }
    for (int p : *primes) {
        if (p < 3) continue;
        long long base = (3LL*p - 1) / 2;
        if (base > n) break;
        long long diff = n - base;
        if (diff >= 0 && (diff % p) == 0) return 0;
    }
    return 1;
}

vector<char> progression_marking_T(int N, int p_max = -1) {
    vector<char> T((size_t)N+1, 1);
    if (N >= 0) T[0] = 0;
    if (p_max < 0) p_max = 2*N + 1;
    vector<int> primes = primes_upto(p_max);
    for (int p : primes) {
        if (p < 3) continue;
        long long base = (3LL*p - 1) / 2;
        if (base > N) break;
        for (long long n = base; n <= N; n += p) T[(size_t)n] = 0;
    }
    return T;
}

vector<char> T_via_sieve(int N) {
    long long limit = 2LL*N + 1;
    if (limit < 2) return vector<char>((size_t)N+1, 0);
    int size = (int)((limit + 1) / 2);
    vector<char> is_prime_odd((size_t)size, 1);
    is_prime_odd[0] = 0;
    int max_i = (int)(floor(sqrt((long double)limit)) / 2);
    for (int i=1;i<=max_i;++i) {
        if (!is_prime_odd[i]) continue;
        int p = 2*i + 1;
        int start = (p * p - 1) / 2;
        for (int j = start; j < size; j += p) is_prime_odd[j] = 0;
    }
    vector<char> T((size_t)N+1, 0);
    for (int n = 0; n <= N; ++n) {
        if (n < size && is_prime_odd[n]) T[(size_t)n] = 1;
    }
    return T;
}

void show_T_sample(const vector<char>& T, int max_show = 40) {
    cout << " n   o_n   T[n]\\n";
    int limit = (int)min((int)T.size()-1, max_show-1);
    for (int n=0;n<=limit;++n) {
        cout << setw(2) << n << "  " << setw(5) << (2*n+1) << "   " << (int)T[(size_t)n] << "\\n";
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << "Prime Spectrum C++ demo (Authors: Gabriel & Noah)\\n";
    int N = 200;
    auto T = T_via_sieve(N);
    show_T_sample(T, 40);
    return 0;
}
"""))

# minimal CMakeLists.txt
write("CMakeLists.txt", textwrap.dedent("""\
cmake_minimum_required(VERSION 3.14)
project(prime_spectrum LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
add_executable(prime_spectrum src/prime_spectrum.cpp)
"""))

# .gitignore
write(".gitignore", textwrap.dedent("""\
build/
*.o
*.exe
*.out
*.zip
"""))

# proof PDF: create a simple PDF with title page using matplotlib
from matplotlib import pyplot as plt
fig = plt.figure(figsize=(8.5,11))
fig.text(0.5, 0.7, "Prime Spectrum–Riemann Correspondence", ha='center', va='center', fontsize=18, weight='bold')
fig.text(0.5, 0.6, "An original proof and analysis", ha='center', va='center', fontsize=12)
fig.text(0.5, 0.5, "Authors:\\nGabriel Neal Christensen\\nNoah Christensen", ha='center', va='center', fontsize=12)
fig.text(0.5, 0.4, "© 2025 Gabriel Neal Christensen & Noah Christensen", ha='center', va='center', fontsize=10)
fig.text(0.1, 0.1, "This document is a placeholder cover page for the full proof PDF.\\nInsert full proof PDF in proof/prime_spectrum_proof.pdf", fontsize=8)
out_pdf_path = os.path.join(base, "proof", "prime_spectrum_proof.pdf")
os.makedirs(os.path.dirname(out_pdf_path), exist_ok=True)
plt.savefig(out_pdf_path)
plt.close(fig)

# Create zip
zip_path = "/mnt/data/prime-spectrum-ip.zip"
with zipfile.ZipFile(zip_path, "w", compression=zipfile.ZIP_DEFLATED) as z:
    for root, dirs, files in os.walk(base):
        for file in files:
            full = os.path.join(root, file)
            rel = os.path.relpath(full, base)
            z.write(full, arcname=rel)

print("Created zip at:", zip_path)
zip_path

